METHOD_0 ( ) { me . IDENT_0 . IDENT_1 . Path actual = me . IDENT_0 . IDENT_1 . IDENT_2 . parse ( STRING_0 , STRING_1 ) ; me . IDENT_0 . IDENT_1 . Path expected = new me . IDENT_0 . IDENT_1 . Path ( STRING_0 , new me . IDENT_0 . IDENT_1 . METHOD_1 ( STRING_2 , null , STRING_3 , null ) , null ) ; "<AssertPlaceHolder>" ; } parse ( java . lang . String , java . lang . String ) { METHOD_2 ( ( ! ( METHOD_3 ( path ) ) ) , STRING_4 ) ; java . lang . String IDENT_3 = path ; if ( IDENT_4 != null ) { if ( ! ( path . startsWith ( ( IDENT_4 + "/" ) ) ) ) { return null ; } IDENT_3 = path . substring ( ( ( IDENT_4 . length ( ) ) + 1 ) ) ; } java . lang . String IDENT_5 ; java . lang . String IDENT_6 = null ; java . lang . String IDENT_7 = null ; java . lang . String IDENT_8 = null ; if ( IDENT_3 . contains ( STRING_5 ) ) { int index = IDENT_3 . indexOf ( STRING_5 ) ; IDENT_5 = IDENT_3 . substring ( 0 , index ) ; java . lang . String IDENT_9 = IDENT_3 . substring ( ( index + 2 ) ) ; IDENT_9 = IDENT_9 . substring ( 0 , IDENT_9 . indexOf ( STRING_6 ) ) ; java . lang . String [ ] IDENT_10 = IDENT_9 . split ( STRING_7 ) ; for ( java . lang . String split : IDENT_10 ) { if ( IDENT_6 == null ) { java . util . regex . IDENT_11 matcher = me . IDENT_0 . IDENT_1 . IDENT_2 . IDENT_12 . matcher ( split ) ; if ( matcher . find ( ) ) { IDENT_6 = matcher . group ( STRING_8 ) ; continue ; } } if ( IDENT_7 == null ) { java . util . regex . IDENT_11 matcher = me . IDENT_0 . IDENT_1 . IDENT_2 . IDENT_13 . matcher ( split ) ; if ( matcher . find ( ) ) { IDENT_7 = matcher . group ( STRING_9 ) ; continue ; } } if ( IDENT_8 == null ) { java . util . regex . IDENT_11 matcher = me . IDENT_0 . IDENT_1 . IDENT_2 . IDENT_14 . matcher ( split ) ; if ( matcher . find ( ) ) { IDENT_8 = matcher . group ( STRING_10 ) ; } } } IDENT_3 = IDENT_3 . substring ( ( ( IDENT_3 . indexOf ( "]" ) ) + 1 ) ) ; if ( IDENT_3 . startsWith ( STRING_11 ) ) { IDENT_3 = IDENT_3 . substring ( 1 ) ; } } else if ( IDENT_3 . contains ( "/" ) ) { IDENT_5 = IDENT_3 . substring ( 0 , IDENT_3 . indexOf ( "/" ) ) ; IDENT_3 = IDENT_3 . substring ( ( ( IDENT_3 . indexOf ( "/" ) ) + 1 ) ) ; } else { IDENT_5 = IDENT_3 ; IDENT_3 = "" ; } me . IDENT_0 . IDENT_1 . METHOD_1 id = new me . IDENT_0 . IDENT_1 . METHOD_1 ( IDENT_5 , IDENT_6 , IDENT_7 , IDENT_8 ) ; return new me . IDENT_0 . IDENT_1 . Path ( IDENT_4 , id , METHOD_4 ( IDENT_3 ) ) ; }
org . junit . Assert . assertEquals ( expected , actual ) 