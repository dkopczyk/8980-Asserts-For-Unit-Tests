METHOD_0 ( ) { org . apache . commons . math3 . random . IDENT_0 IDENT_1 = METHOD_1 ( ) ; for ( int i = 0 ; i < 100 ; ++ i ) { cc . redberry . rings . IDENT_2 . IDENT_3 . IDENT_4 < cc . redberry . rings . IDENT_5 . BigInteger > IDENT_6 = cc . redberry . rings . IDENT_2 . IDENT_3 . IDENT_7 . METHOD_2 ( INT_0 , IDENT_8 . IDENT_9 , IDENT_1 ) ; cc . redberry . rings . IDENT_2 . IDENT_3 . IDENT_4 < cc . redberry . rings . IDENT_5 . BigInteger > IDENT_10 = cc . redberry . rings . IDENT_2 . IDENT_3 . IDENT_7 . METHOD_2 ( 10 , IDENT_8 . IDENT_9 , IDENT_1 ) ; cc . redberry . rings . IDENT_2 . IDENT_3 . IDENT_4 < cc . redberry . rings . IDENT_5 . BigInteger > expected = cc . redberry . rings . IDENT_2 . IDENT_3 . IDENT_11 . METHOD_3 ( IDENT_6 , IDENT_10 , false ) [ 1 ] . METHOD_4 ( ) ; cc . redberry . rings . IDENT_2 . IDENT_3 . IDENT_4 < cc . redberry . rings . IDENT_5 . BigInteger > actual = cc . redberry . rings . IDENT_2 . IDENT_12 . IDENT_13 . METHOD_5 ( cc . redberry . rings . IDENT_2 . IDENT_12 . IDENT_14 . METHOD_6 ( IDENT_6 , 1 , 0 , IDENT_15 . IDENT_16 ) , cc . redberry . rings . IDENT_2 . IDENT_12 . IDENT_14 . METHOD_6 ( IDENT_10 , 1 , 0 , IDENT_15 . IDENT_16 ) ) . METHOD_7 ( ) . METHOD_4 ( ) ; "<AssertPlaceHolder>" ; } } METHOD_4 ( ) { @ cc . redberry . rings . METHOD_8 ( STRING_0 ) cc . redberry . rings . IDENT_17 . IDENT_18 < IDENT_19 > [ ] IDENT_20 = IDENT_21 . stream ( ) . map ( ( e ) -> new IDENT_18 < > ( IDENT_22 , e ) ) . toArray ( cc . redberry . rings . IDENT_17 . IDENT_18 [ ] :: new ) ; int [ ] ex = IDENT_23 . toArray ( ) ; cc . redberry . rings . util . IDENT_24 . METHOD_9 ( IDENT_20 , ex ) ; IDENT_21 . METHOD_10 ( ) ; IDENT_23 . METHOD_10 ( ) ; IDENT_21 . addAll ( cc . redberry . rings . Arrays . stream ( IDENT_20 ) . map ( ( IDENT_25 ) -> IDENT_25 . el ) . collect ( java . util . stream . IDENT_26 . toList ( ) ) ) ; IDENT_23 . addAll ( ex ) ; return this ; }
org . junit . Assert . assertEquals ( expected , actual ) 