METHOD_0 ( ) { org . apache . commons . math3 . linear . IDENT_0 [ ] IDENT_1 = new org . apache . commons . math3 . linear . IDENT_0 [ ] { new org . apache . commons . math3 . linear . METHOD_1 ( new double [ ] { 0 , 1 } ) , new org . apache . commons . math3 . linear . METHOD_1 ( new double [ ] { 2 , 3 } ) , new org . apache . commons . math3 . linear . METHOD_1 ( new double [ ] { 4 , 5 } ) } ; double [ ] actual = IDENT_2 . utils . math . IDENT_3 . METHOD_2 ( IDENT_1 ) ; "<AssertPlaceHolder>" ; } METHOD_2 ( org . apache . commons . math3 . linear . IDENT_0 [ ] [ ] ) { IDENT_2 . utils . lang . IDENT_4 . METHOD_3 ( ( ( grid . length ) >= 1 ) , STRING_0 ) ; IDENT_2 . utils . lang . IDENT_4 . METHOD_3 ( ( ( grid [ 0 ] . length ) >= 1 ) , STRING_1 ) ; final int IDENT_5 = grid . length ; final int IDENT_6 = grid [ 0 ] . length ; org . apache . commons . math3 . linear . IDENT_0 IDENT_7 = grid [ 0 ] [ 0 ] ; IDENT_2 . utils . lang . IDENT_4 . METHOD_4 ( IDENT_7 ) ; int IDENT_8 = IDENT_7 . METHOD_5 ( ) ; int IDENT_9 = IDENT_7 . METHOD_6 ( ) ; final IDENT_2 . utils . collections . IDENT_10 . IDENT_11 list = new IDENT_2 . utils . collections . IDENT_10 . METHOD_7 ( ( ( ( IDENT_5 * IDENT_6 ) * IDENT_8 ) * IDENT_9 ) ) ; final org . apache . commons . math3 . linear . IDENT_12 IDENT_13 = new org . apache . commons . math3 . linear . METHOD_8 ( ) { @ IDENT_2 . utils . math . Override public void METHOD_9 ( int row , int column , double value ) { list . add ( value ) ; } } ; for ( int row = 0 ; row < IDENT_5 ; row ++ ) { for ( int IDENT_14 = 0 ; IDENT_14 < IDENT_6 ; IDENT_14 ++ ) { org . apache . commons . math3 . linear . IDENT_0 IDENT_15 = grid [ row ] [ IDENT_14 ] ; IDENT_15 . METHOD_10 ( IDENT_13 ) ; } } return list . toArray ( ) ; }
org . junit . Assert . assertArrayEquals ( actual , new double [ ] { 0 , 1 , 2 , 3 , 4 , 5 } , 0.0 ) 