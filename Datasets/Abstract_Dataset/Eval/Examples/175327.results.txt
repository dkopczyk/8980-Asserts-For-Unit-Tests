METHOD_0 ( ) { final com . IDENT_0 . runtime . IDENT_1 . IDENT_2 kernel = new com . IDENT_0 . runtime . IDENT_1 . METHOD_1 ( com . IDENT_0 . runtime . IDENT_1 . IDENT_3 ) ; try { final com . IDENT_0 . IDENT_4 range = com . IDENT_0 . runtime . IDENT_1 . IDENT_5 . METHOD_2 ( com . IDENT_0 . runtime . IDENT_1 . IDENT_3 , com . IDENT_0 . runtime . IDENT_1 . IDENT_3 ) ; IDENT_6 = METHOD_3 ( ) ; kernel . METHOD_4 ( false ) ; kernel . METHOD_5 ( IDENT_6 ) ; kernel . execute ( range ) ; "<AssertPlaceHolder>" ; } finally { kernel . METHOD_6 ( ) ; } } validate ( ) { int [ ] IDENT_7 = METHOD_3 ( ) ; int [ ] expected = new int [ com . IDENT_0 . runtime . IDENT_1 . IDENT_3 ] ; for ( int IDENT_8 = 0 ; IDENT_8 < ( com . IDENT_0 . runtime . IDENT_1 . IDENT_3 ) ; IDENT_8 ++ ) { final int IDENT_9 = ( ( com . IDENT_0 . runtime . IDENT_1 . IDENT_3 ) - 1 ) - ( ( IDENT_8 + ( ( com . IDENT_0 . runtime . IDENT_1 . IDENT_3 ) / 2 ) ) OP_0 ( com . IDENT_0 . runtime . IDENT_1 . IDENT_3 ) ) ; expected [ IDENT_9 ] += IDENT_7 [ IDENT_8 ] ; for ( int i = 0 ; i < ( com . IDENT_0 . runtime . IDENT_1 . IDENT_3 ) ; i ++ ) { expected [ IDENT_8 ] += i ; } } int [ ] IDENT_10 = expected ; expected = new int [ com . IDENT_0 . runtime . IDENT_1 . IDENT_3 ] ; for ( int IDENT_8 = 0 ; IDENT_8 < ( com . IDENT_0 . runtime . IDENT_1 . IDENT_3 ) ; IDENT_8 ++ ) { int IDENT_9 = ( IDENT_8 + ( ( com . IDENT_0 . runtime . IDENT_1 . IDENT_3 ) / 2 ) ) OP_0 ( com . IDENT_0 . runtime . IDENT_1 . IDENT_3 ) ; expected [ IDENT_9 ] = IDENT_10 [ IDENT_8 ] ; } for ( int IDENT_8 = 0 ; IDENT_8 < ( com . IDENT_0 . runtime . IDENT_1 . IDENT_3 ) ; IDENT_8 ++ ) { if ( IDENT_8 < ( ( com . IDENT_0 . runtime . IDENT_1 . IDENT_3 ) / 2 ) ) { expected [ IDENT_8 ] += expected [ ( ( ( com . IDENT_0 . runtime . IDENT_1 . IDENT_3 ) - 1 ) - IDENT_8 ) ] ; } } org . junit . Assert . assertArrayEquals ( STRING_0 , expected , IDENT_6 ) ; return true ; }
org . junit . Assert . assertTrue ( validate ( ) ) 