METHOD_0 ( ) { IDENT_0 = new com . IDENT_1 . IDENT_2 . IDENT_3 . METHOD_1 ( com . IDENT_1 . IDENT_2 . IDENT_3 . IDENT_4 . IDENT_5 , com . IDENT_1 . IDENT_2 . IDENT_3 . IDENT_4 . IDENT_6 ) ; double [ ] IDENT_7 = new double [ INT_0 ] ; new IDENT_8 . IDENT_9 < com . IDENT_1 . IDENT_2 . IDENT_10 . IDENT_11 > ( ) { MOD_0 int value = 1 ; @ IDENT_8 . IDENT_12 double [ ] [ ] METHOD_2 ( double [ ] IDENT_13 ) { double [ ] [ ] result = new double [ 2 ] [ 20 ] ; java . util . Arrays . METHOD_3 ( result [ 0 ] , value ) ; ( value ) ++ ; return result ; } } ; double [ ] reference = new double [ 20 ] ; java . util . Arrays . METHOD_3 ( reference , FLOAT_0 ) ; double [ ] IDENT_3 = IDENT_0 . METHOD_4 ( IDENT_7 ) ; "<AssertPlaceHolder>" ; } METHOD_4 ( double [ ] ) { double [ ] IDENT_14 = new double [ IDENT_15 ] ; double [ ] IDENT_16 = new double [ IDENT_17 ] ; int IDENT_18 = 0 ; int IDENT_19 = ( IDENT_17 ) / 2 ; for ( int i = 0 ; ( i + ( IDENT_17 ) ) <= ( IDENT_7 . length ) ; i += IDENT_19 ) { java . lang . System . METHOD_5 ( IDENT_7 , i , IDENT_16 , 0 , IDENT_17 ) ; IDENT_20 . METHOD_6 ( IDENT_16 ) ; double [ ] IDENT_21 = IDENT_0 . METHOD_2 ( IDENT_16 ) [ 0 ] ; for ( int j = 0 ; j < ( IDENT_15 ) ; j ++ ) { IDENT_14 [ j ] += IDENT_21 [ j ] ; } IDENT_18 ++ ; } if ( IDENT_18 > 1 ) { for ( int i = 0 ; i < ( IDENT_15 ) ; i ++ ) { IDENT_14 [ i ] OP_0 IDENT_18 ; } } return IDENT_14 ; }
org . junit . Assert . assertThat ( IDENT_3 , org . hamcrest . Matchers . is ( org . hamcrest . Matchers . equalTo ( reference ) ) ) 