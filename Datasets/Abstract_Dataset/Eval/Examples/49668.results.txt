METHOD_0 ( ) { final IDENT_0 . IDENT_1 graph = new IDENT_0 . METHOD_1 ( ) . METHOD_2 ( new IDENT_0 . IDENT_2 . METHOD_3 ( ) ) . METHOD_4 ( new IDENT_0 . IDENT_3 . METHOD_5 ( ) ) . build ( ) ; graph . connect ( new IDENT_0 . IDENT_4 < java . lang . Boolean > ( ) { @ IDENT_0 . IDENT_2 . IDENT_5 . Override public void METHOD_6 ( java . lang . Boolean result ) { double [ ] data = new double [ 3 ] ; java . util . IDENT_6 IDENT_7 = new java . util . METHOD_7 ( ) ; IDENT_0 . IDENT_2 . algorithm . IDENT_5 . IDENT_8 IDENT_9 = ( ( IDENT_0 . IDENT_2 . algorithm . IDENT_5 . IDENT_8 ) ( graph . METHOD_8 ( 0 , 0 , IDENT_8 . IDENT_10 ) ) ) ; IDENT_9 . set ( IDENT_8 . IDENT_11 , Type . IDENT_12 , 1 ) ; IDENT_9 . set ( IDENT_8 . IDENT_13 , Type . IDENT_12 , 100 ) ; double [ ] IDENT_14 = new double [ 3 ] ; int IDENT_15 = INT_0 ; for ( int i = 0 ; i < IDENT_15 ; i ++ ) { data [ 0 ] = 8 + ( ( IDENT_7 . METHOD_9 ( ) ) * 4 ) ; data [ 1 ] = INT_1 + ( ( IDENT_7 . METHOD_9 ( ) ) * 20 ) ; data [ 2 ] = ( - INT_2 ) + ( ( IDENT_7 . METHOD_9 ( ) ) * 20 ) ; IDENT_9 . METHOD_10 ( data ) ; IDENT_14 [ 0 ] += data [ 0 ] ; IDENT_14 [ 1 ] += data [ 1 ] ; IDENT_14 [ 2 ] += data [ 2 ] ; } IDENT_14 [ 0 ] = ( IDENT_14 [ 0 ] ) / IDENT_15 ; IDENT_14 [ 1 ] = ( IDENT_14 [ 1 ] ) / IDENT_15 ; IDENT_14 [ 2 ] = ( IDENT_14 [ 2 ] ) / IDENT_15 ; double IDENT_16 = FLOAT_0 ; double [ ] res = IDENT_9 . METHOD_11 ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { "<AssertPlaceHolder>" ; } } } ) ; } METHOD_12 ( int ) { if ( index < 0 ) { return - index ; } else { return index ; } }
org . junit . Assert . assertTrue ( ( ( java . lang . Math . METHOD_12 ( ( ( res [ i ] ) - ( IDENT_14 [ i ] ) ) ) ) < IDENT_16 ) ) 