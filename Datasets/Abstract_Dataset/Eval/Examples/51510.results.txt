METHOD_0 ( ) { int IDENT_0 = 5 ; int IDENT_1 = 6 ; int IDENT_2 = 3 ; int n = 4 ; double k = 2.0 ; double IDENT_3 = FLOAT_0 ; double IDENT_4 = FLOAT_1 ; org . nd4j . linalg . api . ndarray . INDArray in = org . nd4j . linalg . factory . Nd4j . METHOD_1 ( new int [ ] { IDENT_2 , IDENT_1 , IDENT_0 , IDENT_0 } ) ; org . nd4j . linalg . api . ndarray . INDArray IDENT_5 = org . nd4j . linalg . factory . Nd4j . METHOD_2 ( IDENT_2 , IDENT_1 , IDENT_0 , IDENT_0 ) ; for ( int m = 0 ; m < IDENT_2 ; m ++ ) { for ( int x = 0 ; x < IDENT_0 ; x ++ ) { for ( int y = 0 ; y < IDENT_0 ; y ++ ) { for ( int i = 0 ; i < IDENT_1 ; i ++ ) { int IDENT_6 = java . lang . Math . max ( 0 , ( i - ( n / 2 ) ) ) ; int IDENT_7 = java . lang . Math . min ( ( IDENT_1 - 1 ) , ( i + ( n / 2 ) ) ) ; double IDENT_8 = 0.0 ; for ( int j = IDENT_6 ; j <= IDENT_7 ; j ++ ) { double d = in . METHOD_3 ( m , j , x , y ) ; IDENT_8 += d * d ; } double out = ( in . METHOD_3 ( m , i , x , y ) ) / ( java . lang . Math . METHOD_4 ( ( k + ( IDENT_3 * IDENT_8 ) ) , IDENT_4 ) ) ; IDENT_5 . METHOD_5 ( m , i , x , y , out ) ; } } } } org . IDENT_9 . IDENT_10 . conf . IDENT_11 . IDENT_12 IDENT_13 = new org . IDENT_9 . IDENT_10 . conf . IDENT_11 . IDENT_12 . Builder ( ) . build ( ) ; org . IDENT_9 . IDENT_10 . conf . IDENT_14 IDENT_15 = new org . IDENT_9 . IDENT_10 . conf . IDENT_14 . Builder ( ) . METHOD_6 ( IDENT_13 ) . build ( ) ; org . IDENT_9 . IDENT_10 . conf . IDENT_11 . org . IDENT_9 . IDENT_10 . IDENT_11 . IDENT_16 . IDENT_12 METHOD_6 = ( ( org . IDENT_9 . IDENT_10 . conf . IDENT_11 . org . IDENT_9 . IDENT_10 . IDENT_11 . IDENT_16 . IDENT_12 ) ( IDENT_13 . METHOD_7 ( IDENT_15 , null , 0 , null , false ) ) ) ; org . nd4j . linalg . api . ndarray . INDArray IDENT_17 = METHOD_6 . METHOD_8 ( in , true , org . IDENT_9 . IDENT_10 . IDENT_18 . IDENT_19 . METHOD_9 ( ) ) ; "<AssertPlaceHolder>" ; } METHOD_9 ( ) { return org . IDENT_9 . IDENT_10 . IDENT_18 . IDENT_19 . builder ( ) . METHOD_10 ( ) . build ( ) ; }
org . junit . Assert . assertEquals ( IDENT_5 , IDENT_17 ) 