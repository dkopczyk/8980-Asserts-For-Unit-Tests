METHOD_0 ( ) { final byte [ ] data = org . eclipse . jgit . lib . Constants . encode ( STRING_0 ) ; int IDENT_0 = INT_0 ; org . eclipse . jgit . util . IDENT_1 . IDENT_2 IDENT_3 = new org . eclipse . jgit . util . IDENT_1 . METHOD_1 ( ( INT_1 * INT_2 ) ) ; org . eclipse . jgit . transport . IDENT_4 . METHOD_2 ( IDENT_3 , IDENT_0 ) ; for ( int i = 0 ; i < IDENT_0 ; i ++ ) { IDENT_3 . write ( ( ( ( org . eclipse . jgit . lib . Constants . IDENT_5 ) << 4 ) | 10 ) ) ; org . eclipse . jgit . transport . IDENT_4 . METHOD_3 ( IDENT_3 , data ) ; } org . eclipse . jgit . transport . IDENT_4 . METHOD_4 ( IDENT_3 ) ; byte [ ] IDENT_6 = IDENT_3 . toByteArray ( ) ; byte [ ] IDENT_7 = new byte [ ( IDENT_6 . length ) + 1 ] ; java . lang . System . METHOD_5 ( IDENT_6 , 0 , IDENT_7 , 0 , IDENT_6 . length ) ; IDENT_7 [ IDENT_6 . length ] = INT_3 ; java . io . InputStream in = new java . io . ByteArrayInputStream ( IDENT_7 ) ; org . eclipse . jgit . transport . IDENT_8 p = index ( in ) ; p . METHOD_6 ( true ) ; p . METHOD_7 ( false ) ; p . METHOD_8 ( true ) ; p . parse ( IDENT_9 . INSTANCE ) ; "<AssertPlaceHolder>" ; } read ( ) { byte [ ] buf = new byte [ 1 ] ; int n = read ( buf , 0 , 1 ) ; return n == 1 ? ( buf [ 0 ] ) & 255 : - 1 ; }
org . junit . Assert . assertEquals ( INT_3 , in . read ( ) ) 