METHOD_0 ( ) { java . lang . String data = " " ; try { hudson . util . IDENT_0 IDENT_1 = hudson . util . IDENT_0 . METHOD_1 ( data ) ; "<AssertPlaceHolder>" ; } catch ( java . lang . IDENT_2 e ) { org . junit . Assert . fail ( ( data + STRING_0 ) ) ; } } METHOD_1 ( java . lang . String ) { if ( ! ( hudson . util . IDENT_0 . METHOD_2 ( data ) ) ) return null ; if ( ( data . startsWith ( STRING_1 ) ) && ( data . METHOD_3 ( STRING_2 ) ) ) { byte [ ] payload ; try { payload = com . IDENT_3 . IDENT_4 . crypto . IDENT_5 . decode ( data . substring ( 1 , ( ( data . length ( ) ) - 1 ) ) . METHOD_4 ( ) ) ; } catch ( java . io . IOException e ) { return null ; } switch ( payload [ 0 ] ) { case hudson . util . IDENT_0 . IDENT_6 : int IDENT_7 = ( ( ( ( ( payload [ 1 ] ) & 255 ) << INT_0 ) | ( ( ( payload [ 2 ] ) & 255 ) << 16 ) ) | ( ( ( payload [ 3 ] ) & 255 ) << 8 ) ) | ( ( payload [ 4 ] ) & 255 ) ; int IDENT_8 = ( ( ( ( ( payload [ 5 ] ) & 255 ) << INT_0 ) | ( ( ( payload [ 6 ] ) & 255 ) << 16 ) ) | ( ( ( payload [ 7 ] ) & 255 ) << 8 ) ) | ( ( payload [ 8 ] ) & 255 ) ; if ( ( payload . length ) != ( ( ( 1 + 8 ) + IDENT_7 ) + IDENT_8 ) ) { return null ; } byte [ ] IDENT_9 = java . util . Arrays . METHOD_5 ( payload , 9 , ( 9 + IDENT_7 ) ) ; byte [ ] code = java . util . Arrays . METHOD_5 ( payload , ( 9 + IDENT_7 ) , payload . length ) ; java . lang . String text ; try { text = new java . lang . String ( hudson . util . IDENT_0 . IDENT_10 . METHOD_1 ( IDENT_9 ) . METHOD_6 ( code ) , UTF_8 ) ; } catch ( java . security . IDENT_11 e ) { return null ; } return new hudson . util . METHOD_7 ( text , IDENT_9 ) ; default : return null ; } } else { try { return hudson . util . IDENT_12 . METHOD_1 ( data , hudson . util . METHOD_7 . IDENT_10 ) ; } catch ( java . security . IDENT_11 e ) { return null ; } catch ( java . io . IDENT_13 e ) { throw new java . lang . METHOD_8 ( e ) ; } catch ( java . io . IOException e ) { return null ; } } }
org . junit . Assert . assertNull ( IDENT_1 ) 