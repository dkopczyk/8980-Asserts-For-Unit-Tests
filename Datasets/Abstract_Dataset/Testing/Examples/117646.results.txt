METHOD_0 ( ) { net . time4j . IDENT_0 . IDENT_1 IDENT_0 = IDENT_1 . IDENT_2 ; "<AssertPlaceHolder>" ; System . out . println ( IDENT_0 . METHOD_1 ( ) ) ; } from ( java . lang . String ) { if ( ! ( IDENT_3 . startsWith ( STRING_0 ) ) ) { throw new java . lang . IllegalArgumentException ( ( STRING_1 1 + IDENT_3 ) ) ; } java . lang . String [ ] IDENT_4 = IDENT_3 . substring ( 9 ) . split ( STRING_2 0 ) ; if ( ( IDENT_4 . length ) == 0 ) { throw new java . lang . IllegalArgumentException ( STRING_3 ) ; } net . time4j . IDENT_0 . internal . IDENT_5 IDENT_6 = net . time4j . IDENT_0 . internal . IDENT_5 . valueOf ( IDENT_4 [ 0 ] ) ; net . time4j . IDENT_0 . IDENT_1 IDENT_0 ; int IDENT_7 = 2 ; switch ( IDENT_6 ) { case IDENT_2 : return net . time4j . IDENT_0 . IDENT_1 . IDENT_2 ; case IDENT_8 : return net . time4j . IDENT_0 . IDENT_1 . IDENT_8 ; case IDENT_9 : return net . time4j . IDENT_0 . IDENT_1 . IDENT_9 ; case IDENT_10 : IDENT_0 = net . time4j . IDENT_0 . IDENT_1 . METHOD_2 ( ) ; IDENT_7 = 1 ; break ; case IDENT_11 : if ( ! ( net . time4j . IDENT_0 . IDENT_1 . METHOD_3 ( IDENT_4 , IDENT_3 ) . equals ( net . time4j . IDENT_12 . of ( INT_0 , 10 , 15 ) ) ) ) { throw new java . lang . IllegalArgumentException ( ( STRING_4 + IDENT_3 ) ) ; } IDENT_0 = net . time4j . IDENT_0 . IDENT_1 . METHOD_4 ( ) ; break ; case IDENT_13 : net . time4j . IDENT_12 IDENT_14 = net . time4j . IDENT_0 . IDENT_1 . METHOD_3 ( IDENT_4 , IDENT_3 ) ; IDENT_0 = net . time4j . IDENT_0 . IDENT_1 . METHOD_5 ( IDENT_14 ) ; break ; default : throw new java . lang . METHOD_6 ( IDENT_6 . name ( ) ) ; } java . lang . String [ ] a = IDENT_4 [ IDENT_7 ] . split ( STRING_5 ) ; if ( a [ 0 ] . equals ( STRING_6 ) ) { java . lang . String IDENT_15 = a [ 1 ] . substring ( 1 , ( ( a [ 1 ] . length ( ) ) - 1 ) ) ; if ( ! ( IDENT_15 . isEmpty ( ) ) ) { java . lang . String [ ] IDENT_16 = IDENT_15 . split ( STRING_2 3 ) ; int [ ] IDENT_17 = new int [ IDENT_16 . length ] ; for ( int i = 0 ; i < ( IDENT_16 . length ) ; i ++ ) { IDENT_17 [ i ] = 1 - ( java . lang . Integer . METHOD_7 ( IDENT_16 [ i ] ) ) ; } IDENT_0 = IDENT_0 . with ( net . time4j . IDENT_0 . IDENT_18 . of ( IDENT_17 ) ) ; } } java . lang . String [ ] b = IDENT_4 [ ( IDENT_7 + 1 ) ] . split ( STRING_5 ) ; if ( b [ 0 ] . equals ( STRING_2 ) ) { java . lang . String IDENT_19 = b [ 1 ] . substring ( 1 , ( ( b [ 1 ] . length ( ) ) - 1 ) ) ; java . lang . String [ ] rules = IDENT_19 . split ( STRING_2 3 ) ; net . time4j . IDENT_0 . IDENT_20 IDENT_21 = null ; for ( int i = 0 ; i < ( rules . length ) ; i ++ ) { java . lang . String [ ] rule = rules [ i ] . split ( STRING_7 ) ; net . time4j . IDENT_0 . IDENT_22 IDENT_23 = net . time4j . IDENT_0 . IDENT_22 . valueOf ( rule [ 0 ] ) ; int IDENT_24 = ( ( rule . length ) == 2 ) ? java . lang . Integer . METHOD_7 ( rule [ 1 ] ) : Integer . MAX_VALUE ; if ( IDENT_21 == null ) { if ( ( IDENT_23 == ( IDENT_22 . IDENT_25 ) ) && ( IDENT_24 == INT_1 ) ) { continue ; } IDENT_21 = IDENT_23 . METHOD_8 ( IDENT_24 ) ; } else { IDENT_21 = IDENT_21 . and ( IDENT_23 . METHOD_8 ( IDENT_24 ) ) ; } } IDENT_0 = IDENT_0 . with ( IDENT_21 ) ; } java . lang . String [ ] c = IDENT_4 [ ( IDENT_7 + 2 ) ] . split ( STRING_5 ) ; if ( c [ 0 ] . equals ( STRING_2 2 ) ) { java . lang . String IDENT_19 = c [ 1 ] . substring ( 1 , ( ( c [ 1 ] . length ( ) ) - 1 ) ) ; if ( ! ( IDENT_19 . equals ( STRING_8 ) ) ) { java . lang . String [ ] IDENT_26 = IDENT_19 . split ( STRING_2 3 ) ; try { net . time4j . IDENT_0 . IDENT_27 IDENT_28 = net . time4j . IDENT_0 . IDENT_27 . valueOf ( IDENT_26 [ 0 ] . substring ( 5 ) ) ; net . time4j . IDENT_12 start = net . time4j . format . IDENT_29 . IDENT_30 . METHOD_9 ( IDENT_26 [ 1 ] . substring ( 7 ) ) ; net . time4j . IDENT_12 end = net . time4j . format . IDENT_29 . IDENT_30 . METHOD_9 ( IDENT_26 [ 2 ] . substring ( 5 ) ) ; switch ( IDENT_28 ) { case IDENT_31 : IDENT_0 = IDENT_0 . with ( net . time4j . IDENT_0 . IDENT_32 . METHOD_10 ( start , end ) ) ; break ; case IDENT_33 : IDENT_0 = IDENT_0 . with ( net . time4j . IDENT_0 . IDENT_32 . METHOD_11 ( start , end ) ) ; break ; case IDENT_34 : IDENT_0 = IDENT_0 . with ( net . time4j . IDENT_0 . IDENT_32 . METHOD_12 ( start , end ) ) ; break ; default : throw new java . lang . IllegalArgumentException ( ( STRING_9 + IDENT_3 ) ) ; } } catch ( java . text . IDENT_35 IDENT_36 ) { throw new java . lang . IllegalArgumentException ( ( STRING_2 4 + IDENT_3 ) ) ; } } } return IDENT_0 ; }
org . junit . Assert . assertThat ( net . time4j . IDENT_0 . IDENT_1 . from ( IDENT_0 . METHOD_1 ( ) ) , org . hamcrest . CoreMatchers . is ( IDENT_0 ) ) 