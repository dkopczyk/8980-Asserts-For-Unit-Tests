METHOD_0 ( ) { java . util . Map < java . lang . String , java . lang . String > map = new java . util . HashMap < java . lang . String , java . lang . String > ( ) ; map . put ( STRING_0 , STRING_1 ) ; target . METHOD_1 ( Method . IDENT_0 , STRING_2 , STRING_3 ) ; IDENT_1 < String > . IDENT_2 result = target . parse ( new org . IDENT_3 . IDENT_4 . IDENT_5 . message . METHOD_2 ( STRING_4 , org . IDENT_3 . IDENT_4 . IDENT_5 . message . METHOD_2 . Method . IDENT_6 , STRING_5 , STRING_6 , STRING_7 ) ) ; "<AssertPlaceHolder>" ; } METHOD_1 ( org . IDENT_3 . IDENT_4 . IDENT_5 . message . IDENT_7 , java . lang . String , T ) { java . lang . String [ ] IDENT_8 = path . split ( "/" ) ; org . IDENT_3 . IDENT_4 . IDENT_5 . IDENT_1 < T > . IDENT_9 state = IDENT_10 ; for ( int i = 0 ; i < ( IDENT_8 . length ) ; ++ i ) { java . lang . String name = IDENT_8 [ i ] ; if ( ( name . startsWith ( STRING_8 ) ) && ( name . METHOD_3 ( STRING_9 ) ) ) { java . lang . String IDENT_11 = name . substring ( 1 , ( ( name . length ( ) ) - 1 ) ) ; state = state . METHOD_4 ( IDENT_11 ) ; } else { state = state . METHOD_5 ( name ) ; } } state . METHOD_6 ( method , result ) ; }
org . junit . Assert . assertNull ( result ) 