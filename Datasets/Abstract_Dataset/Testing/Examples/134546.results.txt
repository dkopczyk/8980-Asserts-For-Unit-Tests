METHOD_0 ( ) { long j = - 1 + 1 ; final long k = j - INT_0 ; int IDENT_0 = INT_1 ; java . util . Map < java . lang . Integer , byte [ ] > IDENT_1 = new java . util . HashMap < java . lang . Integer , byte [ ] > ( ) ; java . util . Set < java . lang . Integer > IDENT_2 = new java . util . HashSet < java . lang . Integer > ( ) ; while ( ( OP_0 j ) > k ) { byte [ ] bytes = METHOD_1 ( j ) . getBytes ( ) ; java . lang . Integer value = com . IDENT_3 . IDENT_4 . IDENT_5 . util . hash . IDENT_6 . METHOD_2 ( bytes , 0 , bytes . length , IDENT_0 ) ; if ( IDENT_1 . containsKey ( value ) ) { IDENT_2 . add ( value ) ; } IDENT_1 . put ( value , bytes ) ; } IDENT_0 = INT_2 ; j = - 1 + 1 ; int IDENT_7 = 0 ; while ( ( OP_0 j ) > k ) { byte [ ] bytes = METHOD_1 ( j ) . getBytes ( ) ; java . lang . Integer value = com . IDENT_3 . IDENT_4 . IDENT_5 . util . hash . IDENT_6 . METHOD_2 ( bytes , 0 , bytes . length , IDENT_0 ) ; if ( ( IDENT_1 . containsKey ( value ) ) && ( IDENT_2 . contains ( value ) ) ) { IDENT_7 ++ ; System . err . println ( ( ( ( ( ( ( ( STRING_0 + value ) + STRING_1 ) + ( new java . lang . String ( bytes ) ) ) + STRING_2 ) + ( new java . lang . String ( IDENT_1 . get ( value ) ) ) ) + STRING_3 ) + IDENT_7 ) ) ; } IDENT_1 . put ( value , bytes ) ; } "<AssertPlaceHolder>" ; } get ( com . IDENT_3 . IDENT_4 . IDENT_5 . IDENT_8 ) { return IDENT_9 . value ; }
org . junit . Assert . assertTrue ( ( IDENT_7 < ( IDENT_2 . size ( ) ) ) ) 