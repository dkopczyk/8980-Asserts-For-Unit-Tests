METHOD_0 ( ) { java . lang . String source = ( ( ( ( ( STRING_0 + ( METHOD_1 ( ) ) ) + STRING_1 ) + ( METHOD_1 ( ) ) ) + STRING_2 ) + ( METHOD_1 ( ) ) ) + STRING_3 ; org . apache . commons . math . linear . IDENT_0 expected = new org . apache . commons . math . linear . METHOD_2 ( new double [ ] { - FLOAT_0 , FLOAT_1 , FLOAT_2 } ) ; org . apache . commons . math . linear . METHOD_2 actual = IDENT_1 . parse ( source ) ; "<AssertPlaceHolder>" ; } parse ( com . google . javascript . IDENT_2 . IDENT_3 ) { try { com . google . javascript . IDENT_2 . IDENT_4 . IDENT_5 . METHOD_3 ( ( STRING_4 + ( IDENT_6 . getName ( ) ) ) ) ; com . google . javascript . IDENT_2 . IDENT_7 . IDENT_8 . IDENT_9 result = com . google . javascript . IDENT_2 . IDENT_7 . IDENT_8 . parse ( IDENT_6 , IDENT_6 . getCode ( ) , compiler . METHOD_4 ( ) , compiler . METHOD_5 ( ) , com . google . javascript . IDENT_2 . IDENT_4 . IDENT_5 ) ; root = result . ast ; compiler . METHOD_6 ( IDENT_6 . getName ( ) , result . IDENT_10 ) ; } catch ( java . io . IOException e ) { compiler . report ( com . google . javascript . IDENT_2 . IDENT_11 . METHOD_7 ( IDENT_3 . IDENT_12 , IDENT_6 . getName ( ) ) ) ; } if ( ( ( root ) == null ) || ( compiler . METHOD_8 ( ) ) ) { root = com . google . javascript . IDENT_13 . IDENT_14 . script ( ) ; } else { compiler . METHOD_9 ( root ) ; } root . METHOD_10 ( IDENT_6 ) ; }
org . junit . Assert . assertEquals ( expected , actual ) 