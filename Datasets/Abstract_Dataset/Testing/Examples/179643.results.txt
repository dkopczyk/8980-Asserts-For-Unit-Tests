METHOD_0 ( ) { final int IDENT_0 = 10 ; final int IDENT_1 = 16 ; final int IDENT_2 = 20 ; long now = org . IDENT_3 . concurrent . IDENT_4 . METHOD_1 ( ) ; now += TimeUnit . IDENT_5 . METHOD_2 ( IDENT_1 ) ; now += TimeUnit . IDENT_6 . METHOD_2 ( IDENT_0 ) ; long result = org . IDENT_3 . concurrent . IDENT_7 . METHOD_3 ( now , IDENT_2 , IDENT_0 ) ; "<AssertPlaceHolder>" ; } METHOD_3 ( long , int , int ) { long IDENT_8 = TimeUnit . IDENT_6 . METHOD_2 ( IDENT_0 ) ; long IDENT_1 = TimeUnit . IDENT_9 . METHOD_4 ( ( now OP_0 ( TimeUnit . IDENT_10 . METHOD_2 ( 1 ) ) ) ) ; if ( IDENT_11 > IDENT_1 ) { IDENT_8 += TimeUnit . IDENT_5 . METHOD_2 ( ( IDENT_11 - IDENT_1 ) ) ; } else if ( IDENT_11 < IDENT_1 ) { IDENT_8 += TimeUnit . IDENT_5 . METHOD_2 ( ( ( ( TimeUnit . IDENT_10 . METHOD_4 ( 1 ) ) - IDENT_1 ) + IDENT_11 ) ) ; } else { long result = org . IDENT_3 . concurrent . IDENT_7 . METHOD_5 ( org . IDENT_3 . util . IDENT_12 . METHOD_6 ( ) , IDENT_0 ) ; if ( ( TimeUnit . IDENT_9 . METHOD_7 ( result ) ) <= IDENT_0 ) { return result ; } else { return result + ( TimeUnit . IDENT_5 . METHOD_2 ( ( ( TimeUnit . IDENT_10 . METHOD_4 ( 1 ) ) - 1 ) ) ) ; } } long offset = now OP_0 ( TimeUnit . IDENT_5 . METHOD_2 ( 1 ) ) ; return IDENT_8 - offset ; }
org . junit . Assert . assertEquals ( TimeUnit . IDENT_5 . METHOD_2 ( ( IDENT_2 - IDENT_1 ) ) , result ) 