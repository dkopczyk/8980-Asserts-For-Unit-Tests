METHOD_0 ( ) { final java . lang . String IDENT_0 = STRING_0 + ( ( STRING_0 + STRING_0 ) + STRING_1 ) ; final byte [ ] key = com . IDENT_1 . IDENT_2 . IDENT_3 . METHOD_1 ( IDENT_0 ) ; final long [ ] IDENT_4 = new long [ ] { INT_0 , INT_1 , INT_2 , INT_3 , INT_4 , INT_5 } ; final long [ ] IDENT_5 = new long [ ] { INT_6 , INT_7 , INT_8 , INT_9 , INT_10 , INT_11 } ; final long IDENT_6 = INT_12 ; com . IDENT_1 . IDENT_2 . IDENT_7 . IDENT_8 cb = new com . IDENT_1 . IDENT_2 . IDENT_7 . METHOD_2 ( ) ; cb . METHOD_3 ( 8 ) . METHOD_4 ( TimeUnit . IDENT_9 . METHOD_5 ( IDENT_6 ) ) ; cb . METHOD_6 ( IDENT_10 . IDENT_11 ) ; com . IDENT_1 . IDENT_2 . IDENT_12 IDENT_13 = new com . IDENT_1 . IDENT_2 . METHOD_7 ( cb . build ( ) ) ; for ( int i = 0 ; i < ( IDENT_4 . length ) ; ++ i ) { "<AssertPlaceHolder>" ; } } METHOD_8 ( byte [ ] , long ) { byte [ ] data = new byte [ 8 ] ; long value = IDENT_14 ; for ( int i = 8 ; ( i OP_0 ) > 0 ; value OP_1 8 ) { data [ i ] = ( ( byte ) ( value ) ) ; } javax . crypto . spec . IDENT_15 IDENT_16 = new javax . crypto . spec . METHOD_9 ( key , config . METHOD_10 ( ) . toString ( ) ) ; try { javax . crypto . IDENT_17 IDENT_18 = javax . crypto . IDENT_17 . getInstance ( config . METHOD_10 ( ) . toString ( ) ) ; IDENT_18 . init ( IDENT_16 ) ; byte [ ] hash = IDENT_18 . METHOD_11 ( data ) ; int offset = ( hash [ ( ( hash . length ) - 1 ) ] ) & 15 ; long IDENT_19 = 0 ; for ( int i = 0 ; i < 4 ; ++ i ) { IDENT_19 OP_2 8 ; IDENT_19 OP_3 ( hash [ ( offset + i ) ] ) & 255 ; } IDENT_19 OP_4 INT_13 ; IDENT_19 OP_5 config . METHOD_12 ( ) ; return ( ( int ) ( IDENT_19 ) ) ; } catch ( java . security . IDENT_20 | java . security . IDENT_21 ex ) { com . IDENT_1 . IDENT_2 . METHOD_7 . LOGGER . log ( IDENT_22 . IDENT_23 , ex . getMessage ( ) , ex ) ; throw new com . IDENT_1 . IDENT_2 . METHOD_13 ( STRING_2 ) ; } }
org . junit . Assert . assertEquals ( IDENT_13 . METHOD_8 ( key , ( ( IDENT_4 [ i ] ) / IDENT_6 ) ) , IDENT_5 [ i ] ) 