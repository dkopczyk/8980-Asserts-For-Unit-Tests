METHOD_0 ( ) { final int IDENT_0 = 16 ; com . IDENT_1 . IDENT_2 . IDENT_3 IDENT_4 = new com . IDENT_1 . IDENT_2 . METHOD_1 ( ) ; int IDENT_5 = 0 ; try ( com . IDENT_1 . store . IDENT_6 index = new com . IDENT_1 . store . METHOD_2 ( IDENT_7 , com . IDENT_1 . IDENT_8 . IDENT_9 , com . IDENT_1 . IDENT_8 . IDENT_10 , 1 , com . IDENT_1 . store . IDENT_11 . IDENT_12 , 0 , false ) ) { for ( int i = 0 ; i < IDENT_0 ; i ++ ) { long [ ] values = new long [ ( IDENT_4 . METHOD_3 ( ) ) OP_0 1000 ] ; IDENT_5 += values . length ; for ( int j = 0 ; j < ( values . length ) ; j ++ ) { values [ j ] = ( IDENT_4 . METHOD_4 ( ) ) OP_0 100 ; } java . util . Arrays . METHOD_5 ( values ) ; for ( int j = 0 ; j < ( values . length ) ; j ++ ) { index . add ( i , values [ j ] ) ; } index . commit ( ) ; } long [ ] expected = new long [ IDENT_5 ] ; int p = 0 ; for ( int i = 0 ; i < IDENT_0 ; i ++ ) { com . IDENT_1 . store . IDENT_13 c = index . METHOD_6 ( i ) ; while ( c . hasNext ( ) ) { expected [ ( p ++ ) ] = c . next ( ) ; } } java . util . Arrays . METHOD_5 ( expected ) ; com . IDENT_1 . IDENT_2 . IDENT_14 IDENT_15 = new com . IDENT_1 . IDENT_2 . METHOD_7 ( ) ; com . IDENT_1 . store . IDENT_13 [ ] IDENT_16 = new com . IDENT_1 . store . IDENT_13 [ IDENT_0 ] ; for ( int i = 0 ; i < IDENT_0 ; i ++ ) { IDENT_16 [ i ] = index . METHOD_8 ( i ) ; if ( IDENT_16 [ i ] . hasNext ( ) ) { IDENT_15 . add ( i , IDENT_16 [ i ] . next ( ) ) ; } } p = 0 ; while ( IDENT_15 . hasNext ( ) ) { int IDENT_17 = IDENT_15 . METHOD_9 ( ) ; long v ; if ( IDENT_16 [ IDENT_17 ] . hasNext ( ) ) { v = IDENT_15 . METHOD_10 ( IDENT_17 , IDENT_16 [ IDENT_17 ] . next ( ) ) ; } else { v = IDENT_15 . METHOD_11 ( ) ; } "<AssertPlaceHolder>" ; } } } METHOD_11 ( ) { long v = buf . METHOD_12 ( 0 ) ; if ( ( OP_1 ( size ) ) > 0 ) { buf . METHOD_13 ( 1 , 0 , size ) ; IDENT_18 . METHOD_13 ( 1 , 0 , size ) ; } return v ; }
org . junit . Assert . assertEquals ( expected [ ( p ++ ) ] , v ) 