METHOD_0 ( ) { org . nd4j . linalg . api . ndarray . INDArray x = org . nd4j . linalg . factory . Nd4j . create ( new double [ ] { 0 , 0 , 1 , 0 , 0 } ) ; org . nd4j . linalg . api . ndarray . INDArray exp = org . nd4j . linalg . factory . Nd4j . create ( new boolean [ ] { false , false , true , false , false } ) ; org . nd4j . linalg . api . ndarray . INDArray IDENT_0 = org . nd4j . linalg . IDENT_1 . IDENT_2 . IDENT_3 . METHOD_1 ( x ) ; "<AssertPlaceHolder>" ; } METHOD_1 ( org . nd4j . linalg . api . ndarray . INDArray ) { IDENT_4 . val IDENT_0 = org . nd4j . linalg . factory . Nd4j . METHOD_2 ( IDENT_5 . IDENT_6 , x . METHOD_3 ( ) , x . METHOD_4 ( ) ) ; if ( x . METHOD_5 ( ) ) { org . nd4j . linalg . factory . Nd4j . METHOD_6 ( ) . exec ( new org . nd4j . linalg . api . IDENT_1 . impl . IDENT_2 . IDENT_7 . METHOD_7 ( x , IDENT_0 ) ) ; } else { org . nd4j . linalg . factory . Nd4j . METHOD_6 ( ) . exec ( new org . nd4j . linalg . api . IDENT_1 . impl . IDENT_8 . IDENT_9 . METHOD_8 ( x , IDENT_0 , FLOAT_0 ) ) ; } return IDENT_0 ; }
org . junit . Assert . assertEquals ( exp , IDENT_0 ) 