METHOD_0 ( ) { if ( ( org . nd4j . linalg . factory . Nd4j . METHOD_1 ( ) . type ( ) ) != ( IDENT_0 . IDENT_1 . IDENT_2 ) ) return ; IDENT_3 . val IDENT_4 = new java . util . concurrent . atomic . METHOD_2 ( 0 ) ; IDENT_3 . val IDENT_5 = INT_0 ; IDENT_3 . val IDENT_6 = new java . util . ArrayList < java . lang . Thread > ( ) ; for ( int e = 0 ; e < IDENT_5 ; e ++ ) { IDENT_3 . val f = e ; IDENT_3 . val t = new java . lang . Thread ( new java . lang . METHOD_3 ( ) { @ org . nd4j . linalg . IDENT_7 . Override public void run ( ) { org . nd4j . linalg . factory . Nd4j . create ( 1 ) ; if ( ( f OP_0 50 ) == 0 ) log . info ( STRING_0 , f ) ; org . nd4j . linalg . factory . Nd4j . METHOD_4 ( ) . METHOD_5 ( ) ; IDENT_4 . METHOD_6 ( ) ; try { java . lang . Thread . sleep ( INT_1 ) ; } catch ( java . lang . IDENT_8 ex ) { ex . printStackTrace ( ) ; } } } ) ; t . start ( ) ; IDENT_6 . add ( t ) ; } for ( IDENT_3 . val t : IDENT_6 ) t . join ( ) ; "<AssertPlaceHolder>" ; } get ( ) { try { IDENT_9 . METHOD_7 ( ) . METHOD_8 ( ) ; return value ; } finally { METHOD_8 . METHOD_7 ( ) . METHOD_9 ( ) ; } }
org . junit . Assert . assertEquals ( IDENT_5 , IDENT_4 . get ( ) ) 