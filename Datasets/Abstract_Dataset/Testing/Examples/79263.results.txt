METHOD_0 ( ) { org . json . JSONObject json = com . google . crypto . IDENT_0 . IDENT_1 . METHOD_1 ( STRING_0 5 ) ; int errors = 0 ; int IDENT_2 = 0 ; org . json . IDENT_3 IDENT_4 = json . METHOD_2 ( STRING_1 ) ; for ( int i = 0 ; i < ( IDENT_4 . length ( ) ) ; i ++ ) { org . json . JSONObject group = IDENT_4 . METHOD_3 ( i ) ; int IDENT_5 = group . METHOD_4 ( STRING_2 ) ; int IDENT_6 = group . METHOD_4 ( STRING_3 ) ; org . json . IDENT_3 tests = group . METHOD_2 ( STRING_0 6 ) ; if ( ( ! ( java . util . Arrays . asList ( IDENT_7 ) . contains ( ( IDENT_5 / 8 ) ) ) ) || ( ! ( java . util . Arrays . asList ( IDENT_8 ) . contains ( ( IDENT_6 / 8 ) ) ) ) ) { IDENT_2 += tests . length ( ) ; continue ; } for ( int j = 0 ; j < ( tests . length ( ) ) ; j ++ ) { org . json . JSONObject IDENT_9 = tests . METHOD_3 ( j ) ; java . lang . String IDENT_10 = java . lang . String . format ( STRING_4 , IDENT_9 . METHOD_4 ( STRING_0 0 ) , IDENT_9 . getString ( STRING_5 ) ) ; byte [ ] IDENT_11 = com . google . crypto . IDENT_0 . IDENT_12 . IDENT_13 . decode ( IDENT_9 . getString ( STRING_0 ) ) ; byte [ ] key = com . google . crypto . IDENT_0 . IDENT_12 . IDENT_13 . decode ( IDENT_9 . getString ( STRING_6 ) ) ; byte [ ] msg = com . google . crypto . IDENT_0 . IDENT_12 . IDENT_13 . decode ( IDENT_9 . getString ( STRING_7 ) ) ; byte [ ] IDENT_14 = com . google . crypto . IDENT_0 . IDENT_12 . IDENT_13 . decode ( IDENT_9 . getString ( STRING_0 7 ) ) ; byte [ ] IDENT_15 = com . google . crypto . IDENT_0 . IDENT_12 . IDENT_13 . decode ( IDENT_9 . getString ( STRING_0 8 ) ) ; byte [ ] IDENT_16 = com . google . crypto . IDENT_0 . IDENT_12 . IDENT_13 . decode ( IDENT_9 . getString ( STRING_8 ) ) ; byte [ ] IDENT_17 = com . google . crypto . IDENT_0 . IDENT_12 . IDENT_18 . METHOD_5 ( IDENT_11 , IDENT_15 , IDENT_16 ) ; java . lang . String result = IDENT_9 . getString ( STRING_9 ) ; try { com . google . crypto . IDENT_0 . IDENT_12 . IDENT_19 IDENT_20 = new com . google . crypto . IDENT_0 . IDENT_12 . METHOD_6 ( key , IDENT_11 . length ) ; byte [ ] IDENT_21 = IDENT_20 . METHOD_7 ( IDENT_17 , IDENT_14 ) ; boolean eq = com . google . crypto . IDENT_0 . IDENT_22 . METHOD_8 ( IDENT_21 , msg ) ; if ( result . equals ( STRING_0 3 ) ) { System . out . METHOD_9 ( STRING_0 2 , IDENT_10 , com . google . crypto . IDENT_0 . IDENT_12 . IDENT_13 . encode ( msg ) , com . google . crypto . IDENT_0 . IDENT_12 . IDENT_13 . encode ( IDENT_21 ) ) ; errors ++ ; } else { if ( ! eq ) { System . out . METHOD_9 ( STRING_0 1 , IDENT_10 , com . google . crypto . IDENT_0 . IDENT_12 . IDENT_13 . encode ( IDENT_21 ) , com . google . crypto . IDENT_0 . IDENT_12 . IDENT_13 . encode ( msg ) ) ; errors ++ ; } } } catch ( java . security . IDENT_23 ex ) { if ( result . equals ( STRING_0 4 ) ) { System . out . METHOD_9 ( STRING_0 9 , IDENT_10 , ex ) ; errors ++ ; } } } } System . out . METHOD_9 ( STRING_6 0 , IDENT_2 ) ; "<AssertPlaceHolder>" ; } encode ( byte [ ] ) { java . lang . String IDENT_24 = STRING_10 ; java . lang . StringBuilder result = new java . lang . StringBuilder ( ( 2 * ( bytes . length ) ) ) ; for ( byte b : bytes ) { int val = b & 255 ; result . append ( IDENT_24 . charAt ( ( val / 16 ) ) ) ; result . append ( IDENT_24 . charAt ( ( val OP_0 16 ) ) ) ; } return result . toString ( ) ; }
org . junit . Assert . assertEquals ( 0 , errors ) 