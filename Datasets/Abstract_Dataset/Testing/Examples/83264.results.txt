METHOD_0 ( ) { final double a = - FLOAT_0 ; final double IDENT_0 = FLOAT_1 ; final double p = FLOAT_2 ; final org . hipparchus . analysis . IDENT_1 f = new org . hipparchus . analysis . function . METHOD_1 ( a , IDENT_0 , p ) ; final double d = FLOAT_3 ; for ( int i = 0 ; i < 10 ; i ++ ) { final double v = i * d ; "<AssertPlaceHolder>" ; } } METHOD_2 ( double ) { int IDENT_2 = 0 ; double IDENT_3 = 0 ; if ( IDENT_4 > FLOAT_4 ) { double [ ] IDENT_5 = new double [ 3 ] ; org . hipparchus . util . IDENT_6 . METHOD_3 ( IDENT_4 , IDENT_5 ) ; IDENT_2 = ( ( int ) ( IDENT_5 [ 0 ] ) ) & 3 ; IDENT_4 = IDENT_5 [ 1 ] ; IDENT_3 = IDENT_5 [ 2 ] ; } else if ( IDENT_4 > FLOAT_5 ) { final org . hipparchus . util . IDENT_6 . IDENT_7 IDENT_8 = new org . hipparchus . util . IDENT_6 . METHOD_4 ( IDENT_4 ) ; IDENT_2 = ( IDENT_8 . METHOD_5 ( ) ) & 3 ; IDENT_4 = IDENT_8 . METHOD_6 ( ) ; IDENT_3 = IDENT_8 . METHOD_7 ( ) ; } switch ( IDENT_2 ) { case 0 : return org . hipparchus . util . IDENT_6 . METHOD_8 ( IDENT_4 , IDENT_3 ) ; case 1 : return - ( org . hipparchus . util . IDENT_6 . METHOD_9 ( IDENT_4 , IDENT_3 ) ) ; case 2 : return - ( org . hipparchus . util . IDENT_6 . METHOD_8 ( IDENT_4 , IDENT_3 ) ) ; case 3 : return org . hipparchus . util . IDENT_6 . METHOD_9 ( IDENT_4 , IDENT_3 ) ; default : return Double . IDENT_9 ; } }
org . junit . Assert . assertEquals ( ( a * ( org . hipparchus . util . IDENT_6 . METHOD_2 ( ( ( IDENT_0 * v ) + p ) ) ) ) , f . value ( v ) , 0 ) 