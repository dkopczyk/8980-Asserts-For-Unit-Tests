METHOD_0 ( ) { final com . IDENT_0 . model . time . IDENT_1 IDENT_2 = com . IDENT_0 . model . time . IDENT_1 . METHOD_1 ( parser . parse ( STRING_0 ) ) ; final java . time . IDENT_3 start = java . time . IDENT_3 . of ( INT_0 , 4 , 10 , 0 , 0 , 0 , 0 , java . time . IDENT_4 . METHOD_2 ( ) ) ; final java . util . Optional < java . time . IDENT_3 > IDENT_5 = IDENT_2 . METHOD_3 ( start ) ; if ( METHOD_3 . METHOD_4 ( ) ) { final java . time . IDENT_3 next = METHOD_3 . get ( ) ; final java . time . IDENT_3 expected = java . time . IDENT_3 . of ( INT_0 , 5 , INT_1 , 8 , 0 , 0 , 0 , java . time . IDENT_4 . METHOD_2 ( ) ) ; "<AssertPlaceHolder>" ; } else { org . junit . Assert . fail ( com . IDENT_0 . model . time . IDENT_6 . IDENT_7 ) ; } } METHOD_3 ( java . time . IDENT_3 ) { com . IDENT_0 . utils . IDENT_8 . METHOD_5 ( date ) ; try { java . time . IDENT_3 IDENT_9 = METHOD_6 ( date ) ; if ( IDENT_9 . equals ( date ) ) { IDENT_9 = METHOD_6 ( date . METHOD_7 ( 1 ) ) ; } return java . util . Optional . of ( IDENT_9 ) ; } catch ( final com . IDENT_0 . model . time . generator . IDENT_10 e ) { return java . util . Optional . empty ( ) ; } }
org . junit . Assert . assertEquals ( expected , next ) 