METHOD_0 ( ) { final java . time . IDENT_0 IDENT_1 = com . IDENT_2 . model . time . generator . IDENT_3 . IDENT_4 ; final com . IDENT_2 . parser . IDENT_5 parser = new com . IDENT_2 . parser . METHOD_1 ( com . IDENT_2 . model . IDENT_6 . IDENT_7 . METHOD_2 ( IDENT_8 . IDENT_9 ) ) ; final com . IDENT_2 . model . time . IDENT_10 IDENT_11 = com . IDENT_2 . model . time . IDENT_10 . METHOD_3 ( parser . parse ( STRING_0 ) ) ; java . time . IDENT_12 date = java . time . IDENT_12 . of ( INT_0 , 3 , 7 , 0 , 0 , 0 , 0 , IDENT_1 ) ; final java . util . Map < java . lang . Integer , java . time . IDENT_13 > IDENT_14 = new java . util . HashMap ( ) ; IDENT_14 . put ( INT_0 , java . time . IDENT_13 . of ( INT_0 , IDENT_15 . IDENT_16 , 8 ) ) ; IDENT_14 . put ( INT_1 , java . time . IDENT_13 . of ( INT_1 , IDENT_15 . IDENT_16 , INT_2 ) ) ; IDENT_14 . put ( INT_3 , java . time . IDENT_13 . of ( INT_3 , IDENT_15 . IDENT_16 , 12 ) ) ; IDENT_14 . put ( INT_4 , java . time . IDENT_13 . of ( INT_4 , IDENT_15 . IDENT_16 , INT_5 ) ) ; IDENT_14 . put ( INT_6 , java . time . IDENT_13 . of ( INT_6 , IDENT_15 . IDENT_16 , 10 ) ) ; IDENT_14 . put ( INT_7 , java . time . IDENT_13 . of ( INT_7 , IDENT_15 . IDENT_16 , 8 ) ) ; IDENT_14 . put ( INT_8 , java . time . IDENT_13 . of ( INT_8 , IDENT_15 . IDENT_16 , INT_9 ) ) ; IDENT_14 . put ( INT_10 , java . time . IDENT_13 . of ( INT_10 , IDENT_15 . IDENT_16 , INT_2 ) ) ; IDENT_14 . put ( INT_11 , java . time . IDENT_13 . of ( INT_11 , IDENT_15 . IDENT_16 , 12 ) ) ; IDENT_14 . put ( INT_12 , java . time . IDENT_13 . of ( INT_12 , IDENT_15 . IDENT_16 , 10 ) ) ; IDENT_14 . put ( INT_13 , java . time . IDENT_13 . of ( INT_13 , IDENT_15 . IDENT_16 , 9 ) ) ; IDENT_14 . put ( INT_14 , java . time . IDENT_13 . of ( INT_14 , IDENT_15 . IDENT_16 , 8 ) ) ; final java . time . IDENT_17 IDENT_18 = java . time . IDENT_17 . METHOD_4 ( ( - 4 ) ) ; final java . time . IDENT_17 IDENT_19 = java . time . IDENT_17 . METHOD_4 ( ( - 5 ) ) ; for ( int IDENT_20 = INT_0 ; IDENT_20 <= INT_14 ; IDENT_20 ++ ) { final java . time . IDENT_13 IDENT_21 = IDENT_14 . get ( IDENT_20 ) ; boolean IDENT_22 = false ; int IDENT_23 = 7 ; while ( IDENT_23 < 15 ) { final java . time . IDENT_24 IDENT_25 = java . time . IDENT_24 . of ( IDENT_20 , IDENT_15 . IDENT_16 , IDENT_23 , 2 , 15 ) ; if ( IDENT_25 . METHOD_5 ( ) . METHOD_6 ( IDENT_21 ) ) { IDENT_23 ++ ; IDENT_22 = true ; continue ; } final java . time . IDENT_17 IDENT_26 = ( IDENT_22 ) ? IDENT_18 : IDENT_19 ; final java . time . IDENT_12 IDENT_27 = java . time . IDENT_12 . METHOD_7 ( IDENT_25 , IDENT_1 , IDENT_26 ) ; final java . util . Optional < java . time . IDENT_12 > IDENT_28 = IDENT_11 . METHOD_8 ( date ) ; assert METHOD_8 . METHOD_9 ( ) ; date = METHOD_8 . get ( ) ; "<AssertPlaceHolder>" ; IDENT_23 ++ ; } } } METHOD_8 ( java . time . IDENT_12 ) { com . IDENT_2 . utils . IDENT_29 . METHOD_10 ( date ) ; try { java . time . IDENT_12 IDENT_30 = METHOD_11 ( date ) ; if ( IDENT_30 . equals ( date ) ) { IDENT_30 = METHOD_11 ( date . METHOD_12 ( 1 ) ) ; } return java . util . Optional . of ( IDENT_30 ) ; } catch ( final com . IDENT_2 . model . time . generator . IDENT_31 e ) { return java . util . Optional . empty ( ) ; } }
org . junit . Assert . assertEquals ( IDENT_27 , date ) 